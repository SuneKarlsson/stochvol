#' Random number and data generation

#' Log chi^2 approximation
#' 
#' Constants defined by Omori for the approximation. This a data.frame with columns
#' p, m, v2, v, a and b.
#' @export
dfModelConstants <- data.frame(
  p = c(0.00609, 0.04775, 0.13057, 0.20674, 0.22715, 0.18842, 0.12047, 0.05591, 0.01575, 0.00115),
  m = c(1.92677, 1.34744, 0.73504, 0.02266, -0.85173, -1.97278, -3.46788, -5.55246, -8.68384, -14.65000),
  v2 = c(0.11265, 0.17788, 0.26768, 0.40611, 0.62699, 0.98583, 1.57469, 2.54498, 4.16591, 7.33342),
  v = sqrt(c(0.11265, 0.17788, 0.26768, 0.40611, 0.62699, 0.98583, 1.57469, 2.54498, 4.16591, 7.33342)),
  a = c(1.01418, 1.02248, 1.03403, 1.05207, 1.08153, 1.13114, 1.21754, 1.37454, 1.68327, 2.50097),
  b = c(0.50710, 0.51124, 0.51701, 0.52604, 0.54076, 0.56557, 0.60877, 0.68728, 0.84163, 1.25049)
)

#' Gaussian mixture generator
#' 
#' Generates Gaussian mixture numbers according to Omori et al., 2007.
#' @author hdarjus \email{hdarjus@gmail.com}
#' @param iN sample size
#' @param iSeed (optional) seed for the random generator
#' @return Random numbers with the Gaussian mixture distribution that
#'   approximates the distribution of the log of chi squared with 1
#'   degree of freedom.
#' @export
fnMixNormal <- function (iN, iSeed=NA) {
  if (is.numeric(iSeed))
    set.seed(iSeed)
  
  vP <- dfModelConstants$p
  vV <- dfModelConstants$v
  vM <- dfModelConstants$m
  
  vInd <- sample(10, size=iN, replace=T, prob=vP)
  result <- rnorm(iN)*vV[vInd] + vM[vInd]
  return(result)
}

#' Dirichlet distribution sampler
#' 
#' Draw from Dirichlet distributions defined on the same support at once.
#' @author hdarjus \email{hdarjus@gmail.com}
#' @param iK number of elements to draw
#' @param mDistributions matrix of probabilities, each rows are distributions, columns are probabilities of the possible values of the distributions
#' @return Matrix of draws having the usual structure, i.e. rows are samples, columns are random variables.
#' @details The input contains the time periods (random variables) in the rows but the output contains them in the columns!
#'   The input complies with the usual structure of time series, and the output with measured data in R.
fnDrawDirichlet <- function (iK, mDistributions) {
  if (is.vector(mDistributions))
    mDistributions <- matrix(mDistributions, nrow = 1)
  mResult <- apply(mDistributions, 1, function (x, iK, iMixCount) sample(iMixCount, iK, replace = T, prob = x), iK, ncol(mDistributions))
  if (iK == 1)
    mResult <- t(mResult)
  mResult
}

#' Discrete log-normal SV generator
#' 
#' Generate discrete time log-normal stochastic volatility series.
#' @author hdarjus \email{hdarjus@gmail.com}
#' @param iN time series length
#' @param dRho parameter rho
#' @param dSigma parameter sigma
#' @param dPhi parameter phi
#' @param dMu parameter mu
#' @param iSeed (optional) seed for the random generator
#' @return Time series generated by the stochastic volatility
#'   model specification. The true model of this time series
#'   is the SV model. The value is a zoo object with columns
#'   y, h, eps and eta.
#' @export
fnGenLogSV <- function (iN, dRho, dSigma, dPhi, dMu, iSeed=NA) {
  if (is.numeric(iSeed))
    set.seed(iSeed)
  # generate residuals, h and y
  vEps <- rnorm(iN)
  vEta <- dSigma * (dRho * vEps + sqrt(1-dRho^2) * rnorm(iN))
  vH <- rep(0, n=iN)
  vH[1] <- rnorm(1, dMu, sd = dSigma/sqrt(1-dPhi^2))
  for (iI in 1:(iN-1)) {
    vH[iI+1] <- dMu + dPhi*(vH[iI] - dMu) + vEta[iI]
  }
  vY <- vEps * exp(vH/2)
  mResult <- cbind(y=vY, h=vH, eps=vEps, eta=vEta)
  zooDat <- zoo::zoo(mResult, order.by = seq_len(iN))
  return(zooDat)
}

#' Discrete log-normal SV transformer
#' 
#' Transform the initial model to an equivalent one according to section 2.1.
#' @author hdarjus \email{hdarjus@gmail.com}
#' @param zooDat output of fnGenLogSV
#' @param dThresh (optional) threshold for numerical stability
#' @return The transformed time series. A zoo object with columns y*, h, eps*, eta and d.
#' @export
fnReformulateLognSV <- function (zooDat, dThresh=1e-10) {
  zooD <- (zooDat[,'eps'] >= 0) - (zooDat[,'eps'] < 0)
  zooEps2 <- zooDat[,'eps']^2
  zooEpsStar <- zoo::ifelse.zoo(zooEps2 < dThresh, log(zooEps2+dThresh), log(zooEps2))
  zooYStar <- zooDat[,'h'] + zooEpsStar
  zooResult <- zoo::merge.zoo(zooYStar, zooDat[,'h'], zooEpsStar, zooDat[,'eta'], zooD)
  colnames(zooResult) <- c('y*', 'h', 'eps*', 'eta', 'd')
  return(zooResult)
}

#' Approximate model generator
#' 
#' Generate time series according to the approximate model.
#' @author hdarjus \email{hdarjus@gmail.com}
#' @param iN (optional) length of the time series. One of iN and vD should
#'   be omitted and the other given
#' @param dMu (optional) parameter mu
#' @param dPhi (optional) parameter phi
#' @param dSigma (optional) parameter sigma
#' @param dRho (optional) parameter rho
#' @param vD (optional) parameters d_t. One of iN and vD should
#'   be omitted and the other given
#' @return List containing dataset generated by the appriximate model,
#'   specified in Omori, 2007, Section 2.3.1. Broad principles. The list
#'   entries are:
#'   \item{dMu}{true mu}
#'   \item{dPhi}{true phi}
#'   \item{dSigma}{true sigma}
#'   \item{dRho}{true rho}
#'   \item{vD}{true signs}
#'   \item{vS}{generated states, according to the prior distribution}
#'   \item{vH}{generated log volatilities. The first entry is generated from the given
#'     conditional normal distribution, the other entries are calculated from the generated
#'     states and white noise}
#'   \item{vEpsStar}{white noise series generated from conditional normal distribution}
#'   \item{vEta}{white noise series geenrated from conditional normal distribution}
#'   \item{vYStar}{transformed log returns calculated from the generated white noise and
#'     volatility series}
#' @export
fnGenApproxLogSV <- function (
    iN = length(vD),
    dMu = rnorm(1, mean = 0, sd = 10),
    dPhi = rbeta(1, 20, 1.5)*2 - 1,
    dSigma = 1/sqrt(rgamma(1, 2.5, scale = 0.025)),
    dRho = runif(1, -1, 1),
    vD = sample(c(-1,1), iN, replace = T, prob = rep(0.5, 2))) {
  
  if ((missing(iN) && missing(vD)) || !(missing(iN) || missing(vD))) 
    stop("One of iN and vD has to be omitted and the other given!")
  if (! all((vD == 1) || (vD == -1)))
    stop("vD should contain only 1s and -1s!")
  
  # s_t
  vS <- sample(10, iN, replace = T, prob = dfModelConstants$p)
  
  # eps*_t and eta_t
  vZ <- rnorm(iN)
  vZStar <- rnorm(iN)
  
  vAj <- dfModelConstants$a[vS]
  vBj <- dfModelConstants$b[vS]
  vMj <- dfModelConstants$m[vS]
  vVj <- dfModelConstants$v[vS]
  
  vEpsStar <- vMj + vVj*vZ
  vEta <- dRho*dSigma*vD*(vAj + vBj*vVj*vZ)*exp(vMj/2) + dSigma*sqrt(1-dRho^2)*vZStar  # vEta[iN] is unused
  
  # h_t
  vH <- rep(0, iN)
  vH[1] <- rnorm(1, mean = dMu, sd = dSigma/sqrt(1-dPhi^2))
  for (iI in seq(2, iN, 1)) {
    vH[iI] <- dMu + dPhi*(vH[iI-1] - dMu) + vEta[iI-1]
  }
  
  # y*_t
  vYStar <- vH + vEpsStar
  
  # result
  return(list(dMu = dMu, dPhi = dPhi, dSigma = dSigma, dRho = dRho, vD = vD, vS = vS, vH = vH,
              vEpsStar = vEpsStar, vEta = vEta, vYStar = vYStar))
}

#' True density function of \eqn{(\eps*,\eta)}
#' 
#' Calculates the conditional density of \eqn{(\eps*,\eta)} given
#' (d, \eqn{\sigma,\rho}). Works on vectors.
#' @param vEps vector of \eqn{\eps*} values
#' @param vEta vector of \eqn{\eta} values
#' @param vD vector of d
#' @param dSigma \eqn{\sigma}
#' @param dRho \eqn{\rho}
#' @return Vector of density values.
fnErrorTrueDensity <- function (vEps, vEta, vD, dSigma, dRho, sCentering) {
  dSigmaCenter <- ifelse(sCentering == "centered", dSigma, 1L)
  dDens <- 1/sqrt(2*pi) * exp((vEps-exp(vEps)) / 2) *
    dnorm(vEta, vD * dRho * dSigmaCenter * exp(vEps/2), sd = dSigmaCenter * sqrt(1-dRho^2))
  return(dDens)
}

#' Approximate density function of \eqn{(\eps*,\eta)}
#' 
#' Calculates the conditional density of \eqn{(\eps*,\eta)} given
#' (d, \eqn{\sigma,\rho}). Works on vectors.
#' @param vEps vector of \eqn{\eps*} values
#' @param vEta vector of \eqn{\eta} values
#' @param vD vector of d
#' @param dSigma \eqn{\sigma}
#' @param dRho \eqn{\rho}
#' @return Vector of density values.
fnErrorApproxDensity <- function (vEps, vEta, vD, dSigma, dRho, sCentering) {
  dSigmaCenter <- ifelse(sCentering == "centered", dSigma, 1L)
  cTime <- length(vEps)
  dDens <- rep(0, cTime)
  for (iTime in seq_len(cTime)) {
    dDens[iTime] <- sum(
      dfModelConstants$p * 
        dnorm(vEps[iTime], dfModelConstants$m, sd = dfModelConstants$v) *
        dnorm(vEta[iTime], vD[iTime] * dRho * dSigmaCenter * exp(dfModelConstants$m/2) *
                (dfModelConstants$a + dfModelConstants$b *
                   (vEps[iTime] - dfModelConstants$m)),
              sd = dSigmaCenter * sqrt(1 - dRho^2))
    )
  }
  return(dDens)
}
